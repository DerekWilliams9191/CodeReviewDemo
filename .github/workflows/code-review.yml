name: Code Review Training

on:
  pull_request:
    types: [opened, reopened, synchronize]
    branches: [ main ]

# This workflow needs to handle PRs from forks, which have security restrictions
# For PRs from forks, we only do initial testing and analysis here, and upload results as artifacts
# The second workflow will use those artifacts to post comments with appropriate permissions 

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      test_passed: ${{ steps.test.outputs.test_passed }}
    
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'
          
      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore
        
      - name: Test
        id: test
        run: |
          TEST_EXIT_CODE=0
          dotnet test --no-build --verbosity normal || TEST_EXIT_CODE=$?
          
          echo "test_passed=$([ $TEST_EXIT_CODE -eq 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          
          # Store test result in file that will be uploaded as an artifact
          echo "TEST_PASSED=$([ $TEST_EXIT_CODE -eq 0 ] && echo 'true' || echo 'false')" > test-results.txt
      
      # Upload the test results as an artifact
      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test-results.txt
      
      # For PRs from forks, we can't comment directly, so we'll upload an artifact for the second workflow
      - name: Create failing test message
        if: steps.test.outputs.test_passed == 'false'
        run: |
          mkdir -p artifacts
          cat > artifacts/review_message.md << EOL
          # âŒ Unit Tests Failed

          The unit tests for this PR are failing. Before we can review the code quality, you need to make the tests pass.

          Please uncomment the necessary code to fix the functionality issues, then we'll review the code for best practices.

          Common issues that might cause test failures:
          - Missing null checks
          - Missing input validation
          - Exception handling is incomplete
          EOL
          
          echo "REQUEST_CHANGES" > artifacts/review_type.txt
          echo "Tests are failing. Please fix the functionality issues first." > artifacts/review_body.txt
          
          # Create an empty line comments file
          echo "[]" > artifacts/line_comments.json
          
      - name: Upload failing test message
        if: steps.test.outputs.test_passed == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: pr_message
          path: artifacts/
          retention-days: 1

  code-review:
    runs-on: ubuntu-latest
    needs: test
    if: needs.test.outputs.test_passed == 'true'
    permissions:
      contents: read
    
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'
      
      # Install jq for JSON processing
      - name: Install jq
        run: sudo apt-get install -y jq
          
      - name: Analyze Code and Create Review Message
        id: analyze
        run: |
          # Create artifacts directory
          mkdir -p artifacts
          
          # Create an empty line comments file
          echo "[]" > artifacts/line_comments.json
          
          # Get all C# files that were modified in this PR
          FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep '\.cs' || echo "")
          
          if [ -z "$FILES" ]; then
            echo "No C# files were modified in this PR."
            ISSUES_FOUND=false
          else
            # Initialize tracking variables
            ISSUES_FOUND=false
            MISSING_NULL_CHECKS=false
            MISSING_VALIDATION=false
            MISSING_DOCUMENTATION=false
            MISSING_EXCEPTION_HANDLING=false
            MISSING_LOGGING=false
            
            # Loop through each modified C# file
            for FILE in $FILES; do
              echo "Analyzing $FILE..."
              
              # Check for null checks (looking for commented out null check patterns) with line numbers
              grep -n "//\s*if\s*(.*\s*==\s*null)" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_NULL_CHECKS=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON
                COMMENT=$(cat << EOF
                {
                  "path": "$FILE",
                  "line": $LINE_NUM,
                  "body": "Missing null check. Please uncomment this line to prevent null reference exceptions."
                }
          EOF
                )
                # Append to the JSON array
                TEMP=$(mktemp)
                jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                mv "$TEMP" artifacts/line_comments.json
              done
              
              # Check for input validation (looking for commented validation code) with line numbers
              grep -n "//\s*if\s*(!.*\.IsValid" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_VALIDATION=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON
                COMMENT=$(cat << EOF
                {
                  "path": "$FILE",
                  "line": $LINE_NUM,
                  "body": "Missing input validation. Please uncomment this validation check."
                }
          EOF
                )
                # Append to the JSON array
                TEMP=$(mktemp)
                jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                mv "$TEMP" artifacts/line_comments.json
              done
              
              # Check for validator validation patterns with line numbers
              grep -n "//\s*validator\.Validate" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_VALIDATION=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON
                COMMENT=$(cat << EOF
                {
                  "path": "$FILE",
                  "line": $LINE_NUM,
                  "body": "Missing validation. Please uncomment this validator call."
                }
          EOF
                )
                # Append to the JSON array
                TEMP=$(mktemp)
                jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                mv "$TEMP" artifacts/line_comments.json
              done
              
              # Check for documentation markers with line numbers
              grep -n "Uncomment for DOCUMENTATION issue" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_DOCUMENTATION=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON
                COMMENT=$(cat << EOF
                {
                  "path": "$FILE",
                  "line": $LINE_NUM,
                  "body": "Missing documentation. Please uncomment the XML documentation in this section."
                }
          EOF
                )
                # Append to the JSON array
                TEMP=$(mktemp)
                jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                mv "$TEMP" artifacts/line_comments.json
              done
              
              # Check for exception handling with line numbers
              grep -n "//\s*try" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_EXCEPTION_HANDLING=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON
                COMMENT=$(cat << EOF
                {
                  "path": "$FILE",
                  "line": $LINE_NUM,
                  "body": "Missing exception handling. Please uncomment this try/catch block."
                }
          EOF
                )
                # Append to the JSON array
                TEMP=$(mktemp)
                jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                mv "$TEMP" artifacts/line_comments.json
              done
              
              # Check for catch blocks with line numbers
              grep -n "//\s*catch" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_EXCEPTION_HANDLING=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON if we haven't already added one for the try block
                if ! grep -q "\"line\": $((LINE_NUM-2))" artifacts/line_comments.json; then
                  COMMENT=$(cat << EOF
                  {
                    "path": "$FILE",
                    "line": $LINE_NUM,
                    "body": "Missing exception handling. Please uncomment this catch block."
                  }
          EOF
                  )
                  # Append to the JSON array
                  TEMP=$(mktemp)
                  jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                  mv "$TEMP" artifacts/line_comments.json
                fi
              done
              
              # Check for logging markers with line numbers
              grep -n "Uncomment for LOGGING issue" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_LOGGING=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON
                COMMENT=$(cat << EOF
                {
                  "path": "$FILE",
                  "line": $LINE_NUM,
                  "body": "Missing logging. Please uncomment the logging statements in this section."
                }
          EOF
                )
                # Append to the JSON array
                TEMP=$(mktemp)
                jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                mv "$TEMP" artifacts/line_comments.json
              done
              
              # Find block commented logger statements with line numbers
              grep -n -P "/\\*.*?_logger\\.Log" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_LOGGING=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON
                COMMENT=$(cat << EOF
                {
                  "path": "$FILE",
                  "line": $LINE_NUM,
                  "body": "Missing logging. Please uncomment this block of logging statements."
                }
          EOF
                )
                # Append to the JSON array
                TEMP=$(mktemp)
                jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                mv "$TEMP" artifacts/line_comments.json
              done
              
              # Find block commented documentation with line numbers
              grep -n -P "/\\*.*?/// <summary>" "$FILE" | while read -r LINE_INFO; do
                LINE_NUM=$(echo "$LINE_INFO" | cut -d':' -f1)
                MATCH_TEXT=$(echo "$LINE_INFO" | cut -d':' -f2-)
                MISSING_DOCUMENTATION=true
                ISSUES_FOUND=true
                
                # Add to line comments JSON
                COMMENT=$(cat << EOF
                {
                  "path": "$FILE",
                  "line": $LINE_NUM,
                  "body": "Missing documentation. Please uncomment this block of XML documentation."
                }
          EOF
                )
                # Append to the JSON array
                TEMP=$(mktemp)
                jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                mv "$TEMP" artifacts/line_comments.json
              done
              
              # Check for STEP 2 marker and any commented code after it
              if grep -q "STEP 2: AFTER TESTS PASS" "$FILE"; then
                STEP2_LINE_NUM=$(grep -n "STEP 2: AFTER TESTS PASS" "$FILE" | cut -d':' -f1)
                echo "Found STEP 2 marker at line $STEP2_LINE_NUM - checking if any STEP 2 code is still commented"
                
                # Look for block comments after STEP 2 marker
                grep -n -A 30 "STEP 2: AFTER TESTS PASS" "$FILE" > step2_section.txt
                BLOCK_START_LINE=$(grep -n "/\*" step2_section.txt | head -1 | cut -d':' -f1)
                
                if [ ! -z "$BLOCK_START_LINE" ]; then
                  # Calculate actual line number in file
                  BLOCK_START_LINE_IN_FILE=$((STEP2_LINE_NUM + BLOCK_START_LINE - 1))
                  echo "Found block comment in STEP 2 section at line $BLOCK_START_LINE_IN_FILE"
                  MISSING_LOGGING=true
                  MISSING_DOCUMENTATION=true
                  ISSUES_FOUND=true
                  
                  # Add to line comments JSON
                  COMMENT=$(cat << EOF
                  {
                    "path": "$FILE",
                    "line": $BLOCK_START_LINE_IN_FILE,
                    "body": "Code quality improvements needed. Please uncomment the STEP 2 code block that contains logging and documentation."
                  }
          EOF
                  )
                  # Append to the JSON array
                  TEMP=$(mktemp)
                  jq --argjson comment "$COMMENT" '. += [$comment]' artifacts/line_comments.json > "$TEMP"
                  mv "$TEMP" artifacts/line_comments.json
                fi
              fi
            done
          fi
          
          # Debug - print final issue status for verification
          echo "Final status:"
          echo "ISSUES_FOUND=$ISSUES_FOUND"
          
          # Count the number of line comments
          LINE_COMMENT_COUNT=$(jq 'length' artifacts/line_comments.json)
          echo "Number of line comments: $LINE_COMMENT_COUNT"
          
          # Save the issues found status to a file
          echo "ISSUES_FOUND=$ISSUES_FOUND" > artifacts/analysis_results.txt
          
          # Create the PR comment content for issue cases
          if [ "$ISSUES_FOUND" == "true" ]; then
            cat > artifacts/review_message.md << EOL
          ## Code Review Results

          ðŸ” **Code Quality Issues Found:**
          EOL
            
            if [ "$MISSING_NULL_CHECKS" == "true" ]; then
              echo "- âŒ **Missing Null Checks**: The code is missing important null checks. Look for commented lines with null checks and uncomment them." >> artifacts/review_message.md
            fi
            
            if [ "$MISSING_VALIDATION" == "true" ]; then
              echo "- âŒ **Missing Input Validation**: The code doesn't validate inputs before processing them. Find and uncomment the validation code." >> artifacts/review_message.md
            fi
            
            if [ "$MISSING_DOCUMENTATION" == "true" ]; then
              echo "- âŒ **Missing Documentation**: The code lacks proper XML documentation. Uncomment the documentation sections." >> artifacts/review_message.md
            fi
            
            if [ "$MISSING_EXCEPTION_HANDLING" == "true" ]; then
              echo "- âŒ **Missing Exception Handling**: The code doesn't properly handle exceptions. Uncomment the try/catch blocks." >> artifacts/review_message.md
            fi
            
            if [ "$MISSING_LOGGING" == "true" ]; then
              echo "- âŒ **Missing Logging**: The code doesn't include proper logging. Uncomment the logging statements." >> artifacts/review_message.md
            fi
            
            echo -e "\nPlease address these code quality issues by uncommenting the correct code sections and update your PR. See the line comments on the PR for specific locations of issues." >> artifacts/review_message.md
            
            # Create the PR review body (shorter version that goes with the PR review)
            echo "Code quality issues found. Please address them by uncommenting the necessary code. See line comments for details." > artifacts/review_body.txt
            
            # Indicate this should be a "REQUEST_CHANGES" review
            echo "REQUEST_CHANGES" > artifacts/review_type.txt
          else
            # Create the PR comment for success cases
            cat > artifacts/review_message.md << EOL
          ## Code Review Results

          ðŸŽ‰ **Great job!** All tests are passing and code quality standards have been met.
          EOL
            
            # Create the PR review body for success
            echo "All code quality standards have been met. Great job!" > artifacts/review_body.txt
            
            # Indicate this should be an "APPROVE" review
            echo "APPROVE" > artifacts/review_type.txt
          fi

      # Upload the PR review content as an artifact for the second workflow
      - name: Upload PR review artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pr_message
          path: artifacts/
          retention-days: 1
