name: Code Review Training

on:
  pull_request:
    types: [opened, reopened, synchronize]
    branches: [ main ]

# This workflow needs to handle PRs from forks, which have security restrictions
# For PRs from forks, we only do initial testing and analysis here, and upload results as artifacts
# The second workflow will use those artifacts to post comments with appropriate permissions 

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      test_passed: ${{ steps.test.outputs.test_passed }}
    
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'
          
      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore
        
      - name: Test
        id: test
        run: |
          TEST_EXIT_CODE=0
          dotnet test --no-build --verbosity normal || TEST_EXIT_CODE=$?
          
          echo "test_passed=$([ $TEST_EXIT_CODE -eq 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          
          # Store test result in file that will be uploaded as an artifact
          echo "TEST_PASSED=$([ $TEST_EXIT_CODE -eq 0 ] && echo 'true' || echo 'false')" > test-results.txt
      
      # Upload the test results as an artifact
      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test-results.txt
      
      # For PRs from forks, we can't comment directly, so we'll upload an artifact for the second workflow
      - name: Create failing test message
        if: steps.test.outputs.test_passed == 'false'
        run: |
          mkdir -p artifacts
          cat > artifacts/review_message.md << EOL
          # âŒ Unit Tests Failed

          The unit tests for this PR are failing. Before we can review the code quality, you need to make the tests pass.

          Please uncomment the necessary code to fix the functionality issues, then we'll review the code for best practices.

          Common issues that might cause test failures:
          - Missing null checks
          - Missing input validation
          - Exception handling is incomplete
          EOL
          
          echo "REQUEST_CHANGES" > artifacts/review_type.txt
          echo "Tests are failing. Please fix the functionality issues first." > artifacts/review_body.txt
          
      - name: Upload failing test message
        if: steps.test.outputs.test_passed == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: pr_message
          path: artifacts/
          retention-days: 1

  code-review:
    runs-on: ubuntu-latest
    needs: test
    if: needs.test.outputs.test_passed == 'true'
    permissions:
      contents: read
    
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'
          
      - name: Analyze Code and Create Line-Specific Comments
        id: analyze
        run: |
          # Create artifacts directory
          mkdir -p artifacts
          
          # Get all C# files that were modified in this PR
          FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep '\.cs')

          # Initialize tracking variables
          ISSUES_FOUND=false
          MISSING_NULL_CHECKS=false
          MISSING_VALIDATION=false
          MISSING_DOCUMENTATION=false
          MISSING_EXCEPTION_HANDLING=false
          MISSING_LOGGING=false
          
          # Create an array to store line-specific comments
          echo "[]" > artifacts/line_comments.json
          
          # Store the PR base SHA and head SHA for later use in comments
          echo "${{ github.event.pull_request.base.sha }}" > artifacts/pr_base_sha.txt
          echo "${{ github.event.pull_request.head.sha }}" > artifacts/pr_head_sha.txt
          
          # Save PR number for reference
          echo "${{ github.event.pull_request.number }}" > artifacts/pr_number.txt
          
          # Loop through each modified C# file
          for FILE in $FILES; do
            echo "Analyzing $FILE..."
            
            # Create a temporary file to store line-specific issues
            LINE_ISSUES_FILE="line_issues_$(basename "$FILE").json"
            echo "[]" > "$LINE_ISSUES_FILE"
            
            # Get the line numbers with null check issues and capture the actual code
            NULL_CHECK_LINES=$(grep -n "//\s*if\s*(.*\s*==\s*null)" "$FILE")
            if [ -n "$NULL_CHECK_LINES" ]; then
              MISSING_NULL_CHECKS=true
              ISSUES_FOUND=true
              
              # Process each line with a null check issue
              echo "$NULL_CHECK_LINES" | while IFS=: read -r LINE_NUM LINE_CONTENT; do
                # Extract the actual code from the comment for better feedback
                CODE_SNIPPET=$(echo "$LINE_CONTENT" | sed -E 's/^[ \t]*\/\/[ \t]*(.*)/\1/')
                
                COMMENT="**Missing Null Check**

This appears to be a commented-out null check. For proper error handling, uncomment this line:

\`\`\`csharp
${CODE_SNIPPET}
\`\`\`

Null checks are essential for preventing NullReferenceExceptions and ensuring robust code."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
            # Check for input validation issues and capture the actual code
            VALIDATION_LINES=$(grep -n "//\s*if\s*(!.*\.IsValid" "$FILE")
            VALIDATION_LINES2=$(grep -n "//\s*validator\.Validate" "$FILE")
            
            # Process validation check lines
            if [ -n "$VALIDATION_LINES" ]; then
              MISSING_VALIDATION=true
              ISSUES_FOUND=true
              
              echo "$VALIDATION_LINES" | while IFS=: read -r LINE_NUM LINE_CONTENT; do
                # Extract the actual code from the comment
                CODE_SNIPPET=$(echo "$LINE_CONTENT" | sed -E 's/^[ \t]*\/\/[ \t]*(.*)/\1/')
                
                COMMENT="**Missing Input Validation**

This commented code contains important validation logic. To ensure data integrity, uncomment this validation:

\`\`\`csharp
${CODE_SNIPPET}
\`\`\`

Proper input validation prevents invalid data from corrupting your application state."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
            # Process validator lines
            if [ -n "$VALIDATION_LINES2" ]; then
              MISSING_VALIDATION=true
              ISSUES_FOUND=true
              
              echo "$VALIDATION_LINES2" | while IFS=: read -r LINE_NUM LINE_CONTENT; do
                # Extract the actual code from the comment
                CODE_SNIPPET=$(echo "$LINE_CONTENT" | sed -E 's/^[ \t]*\/\/[ \t]*(.*)/\1/')
                
                COMMENT="**Missing Validator Call**

This commented validator code is necessary for proper validation. Uncomment this line:

\`\`\`csharp
${CODE_SNIPPET}
\`\`\`

Validators provide a centralized way to enforce business rules across your application."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
            # Check for documentation issues with marker comments
            DOC_LINES=$(grep -n "Uncomment for DOCUMENTATION issue" "$FILE")
            if [ -n "$DOC_LINES" ]; then
              MISSING_DOCUMENTATION=true
              ISSUES_FOUND=true
              
              echo "$DOC_LINES" | while IFS=: read -r LINE_NUM LINE_CONTENT; do
                # Look ahead a few lines to find the actual documentation
                DOC_BLOCK=$(tail -n +$LINE_NUM "$FILE" | head -5)
                
                COMMENT="**Missing Documentation**

Documentation marker found. Please uncomment the XML documentation near this line.

Documentation helps other developers understand your code's purpose, parameters, and return values.

Look for commented XML doc blocks with \`<summary>\`, \`<param>\`, and \`<returns>\` tags."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
            # Find block commented documentation
            DOC_BLOCK_LINES=$(grep -n -A 1 "/\*.*/// <summary>" "$FILE" | head -1)
            if [ -n "$DOC_BLOCK_LINES" ]; then
              MISSING_DOCUMENTATION=true
              ISSUES_FOUND=true
              
              LINE_NUM=$(echo "$DOC_BLOCK_LINES" | cut -d: -f1)
              
              # Extract the first couple of lines of the doc block for context
              DOC_CONTENT=$(tail -n +$LINE_NUM "$FILE" | head -3 | sed -E 's/^[ \t]*\/\*[ \t]*(.*)/\1/')
              
              COMMENT="**Missing XML Documentation**

This appears to be block-commented documentation. XML documentation is required for public classes and methods:

\`\`\`csharp
/// <summary>
/// [Description of the method/class]
/// </summary>
\`\`\`

Uncomment this block to properly document your code and enable IntelliSense help for other developers."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
            # Check for exception handling issues
            TRY_LINES=$(grep -n "//\s*try" "$FILE")
            CATCH_LINES=$(grep -n "//\s*catch" "$FILE")
            
            # Process try block lines
            if [ -n "$TRY_LINES" ]; then
              MISSING_EXCEPTION_HANDLING=true
              ISSUES_FOUND=true
              
              echo "$TRY_LINES" | while IFS=: read -r LINE_NUM LINE_CONTENT; do
                # Extract the actual code
                CODE_SNIPPET=$(echo "$LINE_CONTENT" | sed -E 's/^[ \t]*\/\/[ \t]*(.*)/\1/')
                
                COMMENT="**Missing Exception Handling: Try Block**

This commented code contains a try block that should be uncommented:

\`\`\`csharp
${CODE_SNIPPET}
\`\`\`

Proper exception handling prevents application crashes and provides a better user experience when errors occur. Make sure to also uncomment any associated catch and finally blocks."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
            # Process catch block lines
            if [ -n "$CATCH_LINES" ]; then
              MISSING_EXCEPTION_HANDLING=true
              ISSUES_FOUND=true
              
              echo "$CATCH_LINES" | while IFS=: read -r LINE_NUM LINE_CONTENT; do
                # Extract the actual code
                CODE_SNIPPET=$(echo "$LINE_CONTENT" | sed -E 's/^[ \t]*\/\/[ \t]*(.*)/\1/')
                
                COMMENT="**Missing Exception Handling: Catch Block**

This commented code contains a catch block that should be uncommented:

\`\`\`csharp
${CODE_SNIPPET}
\`\`\`

Exception handling is incomplete without proper catch blocks. Remember to log exceptions and provide appropriate user feedback."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
            # Check for logging issues
            LOGGING_LINES=$(grep -n "Uncomment for LOGGING issue" "$FILE")
            LOGGER_LINES=$(grep -n -A 1 "/\*.*_logger\.Log" "$FILE" | head -1)
            
            # Process logging marker lines
            if [ -n "$LOGGING_LINES" ]; then
              MISSING_LOGGING=true
              ISSUES_FOUND=true
              
              echo "$LOGGING_LINES" | while IFS=: read -r LINE_NUM LINE_CONTENT; do
                COMMENT="**Missing Logging**

Logging marker found near this line. Proper logging is essential for:

- Troubleshooting production issues
- Monitoring application health
- Tracking user activity and errors
- Performance analysis

Look for commented logging statements nearby and uncomment them."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
            # Process commented logger calls
            if [ -n "$LOGGER_LINES" ]; then
              MISSING_LOGGING=true
              ISSUES_FOUND=true
              
              LINE_NUM=$(echo "$LOGGER_LINES" | cut -d: -f1)
              
              # Get a few lines of context for the logger
              LOGGER_BLOCK=$(tail -n +$LINE_NUM "$FILE" | head -3 | grep -v "^\-\-" | sed -E 's/^[ \t]*\/\*[ \t]*(.*)/\1/')
              
              COMMENT="**Missing Logger Calls**

Found block-commented logging code. Application logging is critical for production monitoring:

\`\`\`csharp
// Logging example
_logger.LogInformation("Operation completed: {Result}", result);
\`\`\`

Uncomment the logger calls in this block to improve application observability."
                
                # Add to the line issues JSON
                TMP=$(jq --arg file "$FILE" --arg line "$LINE_NUM" --arg body "$COMMENT" \
                  '. += [{"path": $file, "line": $line|tonumber, "body": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              done
            fi
            
": $body}]' "$LINE_ISSUES_FILE")
                echo "$TMP" > "$LINE_ISSUES_FILE"
              fi
            fi
            
            # Merge line issues for this file into the main line comments JSON
            jq -s '.[0] + .[1]' artifacts/line_comments.json "$LINE_ISSUES_FILE" > artifacts/temp.json
            mv artifacts/temp.json artifacts/line_comments.json
            rm "$LINE_ISSUES_FILE"
          done
          
          # Save the issues found status to a file
          echo "ISSUES_FOUND=$ISSUES_FOUND" > artifacts/analysis_results.txt
          echo "MISSING_NULL_CHECKS=$MISSING_NULL_CHECKS" >> artifacts/analysis_results.txt
          echo "MISSING_VALIDATION=$MISSING_VALIDATION" >> artifacts/analysis_results.txt
          echo "MISSING_DOCUMENTATION=$MISSING_DOCUMENTATION" >> artifacts/analysis_results.txt
          echo "MISSING_EXCEPTION_HANDLING=$MISSING_EXCEPTION_HANDLING" >> artifacts/analysis_results.txt
          echo "MISSING_LOGGING=$MISSING_LOGGING" >> artifacts/analysis_results.txt
          
          # Create the PR comment content for issue cases
          if [ "$ISSUES_FOUND" == "true" ]; then
            cat > artifacts/review_message.md << EOL
          ## Code Review Results

          ðŸ” **Code Quality Issues Found:**
          EOL
            
            if [ "$MISSING_NULL_CHECKS" == "true" ]; then
              echo "- âŒ **Missing Null Checks**: The code is missing important null checks. Look for commented lines with null checks and uncomment them." >> artifacts/review_message.md
            fi
            
            if [ "$MISSING_VALIDATION" == "true" ]; then
              echo "- âŒ **Missing Input Validation**: The code doesn't validate inputs before processing them. Find and uncomment the validation code." >> artifacts/review_message.md
            fi
            
            if [ "$MISSING_DOCUMENTATION" == "true" ]; then
              echo "- âŒ **Missing Documentation**: The code lacks proper XML documentation. Uncomment the documentation sections." >> artifacts/review_message.md
            fi
            
            if [ "$MISSING_EXCEPTION_HANDLING" == "true" ]; then
              echo "- âŒ **Missing Exception Handling**: The code doesn't properly handle exceptions. Uncomment the try/catch blocks." >> artifacts/review_message.md
            fi
            
            if [ "$MISSING_LOGGING" == "true" ]; then
              echo "- âŒ **Missing Logging**: The code doesn't include proper logging. Uncomment the logging statements." >> artifacts/review_message.md
            fi
            
            echo -e "\nPlease address these code quality issues by uncommenting the correct code sections and update your PR. **Line-specific comments have been added to the affected code.**" >> artifacts/review_message.md
            
            # Create the PR review body (shorter version that goes with the PR review)
            echo "Code quality issues found. Please see the line-specific comments for details." > artifacts/review_body.txt
            
            # Indicate this should be a "REQUEST_CHANGES" review
            echo "REQUEST_CHANGES" > artifacts/review_type.txt
          else
            # Create the PR comment for success cases
            cat > artifacts/review_message.md << EOL
          ## Code Review Results

          ðŸŽ‰ **Great job!** All tests are passing and code quality standards have been met.
          EOL
            
            # Create the PR review body for success
            echo "All code quality standards have been met. Great job!" > artifacts/review_body.txt
            
            # Indicate this should be an "APPROVE" review
            echo "APPROVE" > artifacts/review_type.txt
          fi

      # Upload the PR review content as an artifact for the second workflow
      - name: Upload PR review artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pr_message
          path: artifacts/
          retention-days: 1
